        -:    0:Source:/home/lerakry/github_tp_c_cpp_h1/tp_c-cpp_homework1/DZ2/project/src/functions.c
        -:    0:Graph:/home/lerakry/github_tp_c_cpp_h1/tp_c-cpp_homework1/DZ2/cmake-build-debug-coverage/CMakeFiles/compute_parallal.dir/project/src/functions.c.gcno
        -:    0:Data:/home/lerakry/github_tp_c_cpp_h1/tp_c-cpp_homework1/DZ2/cmake-build-debug-coverage/CMakeFiles/compute_parallal.dir/project/src/functions.c.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2:// Created by lerakry on 24.10.2020.
        -:    3://
        -:    4:
        -:    5:#include <stdio.h>
        -:    6:#include <string.h>
        -:    7:#include <stdlib.h>
        -:    8:#include "utils.h"
        -:    9:
    #####:   10:FILE* get_file(const char* file_name, const char* params) {
    $$$$$:   10-block  0
    #####:   11:    const char file_path[] = "/home/lerakry/github_tp_c_cpp_h1/tp_c-cpp_homework1/DZ2/tests/";
        -:   12:
        -:   13:    char full_file_path[100];
        -:   14:
    #####:   15:    snprintf(full_file_path, sizeof full_file_path, "%s%s", file_path, file_name);
        -:   16:
    #####:   17:    FILE* file = fopen(full_file_path, params);
    $$$$$:   17-block  0
        -:   18:
    #####:   19:    if ( file == NULL ) {
        -:   20://        perror(file_name);
        -:   21://        exit(EXIT_FAILURE);
        -:   22:        return NULL;
        -:   23:    }
    #####:   24:    return file;
    $$$$$:   24-block  0
        -:   25:}
        -:   26:
    #####:   27:Matrix* get_matrix(FILE* file) {
    $$$$$:   27-block  0
    #####:   28:    if ( file == NULL )
    $$$$$:   28-block  0
        -:   29:        return NULL;
        -:   30:
    #####:   31:    Matrix* matrix = (Matrix*)malloc(sizeof(Matrix) * 1);
    #####:   32:    if ( matrix == NULL ) {
    $$$$$:   32-block  0
        -:   33:        return NULL;
        -:   34:    }
        -:   35:
    #####:   36:    if ( fscanf(file, "%d", &matrix->rows) != 1 ) {
    $$$$$:   36-block  0
    #####:   37:        free(matrix);
    #####:   38:        return NULL;
    $$$$$:   38-block  0
        -:   39:    }
    #####:   40:    if ( fscanf(file, "%d", &matrix->columns) != 1 ) {
    $$$$$:   40-block  0
    #####:   41:        free(matrix);
    #####:   42:        return NULL;
    $$$$$:   42-block  0
        -:   43:    }
        -:   44:
    #####:   45:    matrix->matrix = (double**) malloc(matrix->rows * sizeof(double*));
    #####:   46:    if ( matrix->matrix == NULL ) {
    $$$$$:   46-block  0
    $$$$$:   46-block  1
    #####:   47:        free(matrix);
    #####:   48:        return NULL;
    $$$$$:   48-block  0
        -:   49:    }
    #####:   50:    for (int i = 0; i < matrix->rows; ++i) {
    $$$$$:   50-block  0
    $$$$$:   50-block  1
    $$$$$:   50-block  2
    #####:   51:        matrix->matrix[i] = (double*) malloc(matrix->columns * sizeof(double));
    #####:   52:        if ( matrix->matrix[i] == NULL ) {
    $$$$$:   52-block  0
    #####:   53:            free(matrix->matrix);
    #####:   54:            free(matrix);
    #####:   55:            return NULL;
    $$$$$:   55-block  0
        -:   56:        }
        -:   57:    }
        -:   58:
        -:   59:    double number;
    #####:   60:    for (int i = 0; i < matrix->rows; ++i) {
    $$$$$:   60-block  0
    $$$$$:   60-block  1
    $$$$$:   60-block  2
    #####:   61:        for (int j = 0; j < matrix->columns && fscanf(file, "%lf", &number) == 1; ++j) {
    $$$$$:   61-block  0
    $$$$$:   61-block  1
    $$$$$:   61-block  2
    #####:   62:            matrix->matrix[i][j] = number;
        -:   63:        }
        -:   64:    }
        -:   65:    return matrix;
        -:   66:}
        -:   67:
    #####:   68:bool correct_transposition(const double* a1, const double* a2, int matrix_size) {
    $$$$$:   68-block  0
    #####:   69:    for ( int i = 0; i < matrix_size; ++i ) {
    $$$$$:   69-block  0
    $$$$$:   69-block  1
    $$$$$:   69-block  2
    #####:   70:        if ( a1[i] != a2[i] ) {
    $$$$$:   70-block  0
        -:   71:            return false;
        -:   72:        }
        -:   73:    }
        -:   74:    return true;
        -:   75:}
        -:   76:
    #####:   77:void free_memory(Matrix* matrix) {
    $$$$$:   77-block  0
    #####:   78:    for ( int i = 0; i < matrix->rows; ++i ) {
    $$$$$:   78-block  0
    $$$$$:   78-block  1
    $$$$$:   78-block  2
    #####:   79:        free(matrix->matrix[i]);
        -:   80:    }
    #####:   81:    free(matrix->matrix);
    #####:   82:    free(matrix);
    #####:   83:}
        -:   84:
    #####:   85:bool right_matrix(double** a, int rows, int columns, const double* b) {
    $$$$$:   85-block  0
    #####:   86:    for ( int i = 0; i < rows; ++i ) {
    $$$$$:   86-block  0
    $$$$$:   86-block  1
    $$$$$:   86-block  2
    $$$$$:   86-block  3
    #####:   87:        for ( int j = 0; j < columns; ++j ) {
    $$$$$:   87-block  0
    $$$$$:   87-block  1
    #####:   88:            if ( a[i][j] != *(b + i * columns + j) ) {
    $$$$$:   88-block  0
        -:   89:                return false;
        -:   90:            }
        -:   91:        }
        -:   92:    }
        -:   93:    return true;
        -:   94:}
        -:   95:
        -:   96:
